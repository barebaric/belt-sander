#ifndef ODRIVE_H
#define ODRIVE_H

#include <SoftwareSerial.h>

enum AxisState {
    AXIS_STATE_UNDEFINED                     = 0,
    AXIS_STATE_IDLE                          = 1,
    AXIS_STATE_STARTUP_SEQUENCE              = 2,
    AXIS_STATE_FULL_CALIBRATION_SEQUENCE     = 3,
    AXIS_STATE_MOTOR_CALIBRATION             = 4,
    AXIS_STATE_ENCODER_INDEX_SEARCH          = 6,
    AXIS_STATE_ENCODER_OFFSET_CALIBRATION    = 7,
    AXIS_STATE_CLOSED_LOOP_CONTROL           = 8,
    AXIS_STATE_LOCKIN_SPIN                   = 9,
    AXIS_STATE_ENCODER_DIR_FIND              = 10,
    AXIS_STATE_HOMING                        = 11,
    AXIS_STATE_ENCODER_HALL_POLARITY_CALIBRATION = 12,
    AXIS_STATE_ENCODER_HALL_PHASE_CALIBRATION = 13
};

// Axis error codes
enum AxisError {
    AXIS_ERROR_NONE = 0x00,
    AXIS_ERROR_INVALID_STATE = 0x01,
    AXIS_ERROR_DC_BUS_UNDER_VOLTAGE = 0x02,
    AXIS_ERROR_DC_BUS_OVER_VOLTAGE = 0x04,
    AXIS_ERROR_CURRENT_MEASUREMENT_TIMEOUT = 0x08,
    AXIS_ERROR_BRAKE_RESISTOR_DISARMED = 0x10,
    AXIS_ERROR_MOTOR_DISARMED = 0x20,
    AXIS_ERROR_MOTOR_FAILED = 0x40,
    AXIS_ERROR_SENSORLESS_ESTIMATOR_FAILED = 0x80,
    AXIS_ERROR_ENCODER_FAILED = 0x100,
    AXIS_ERROR_CONTROLLER_FAILED = 0x200,
    AXIS_ERROR_POS_CTRL_DURING_SENSORLESS = 0x400,
    AXIS_ERROR_WATCHDOG_TIMER_EXPIRED = 0x800,
    AXIS_ERROR_MIN_ENDSTOP_PRESSED = 0x1000,
    AXIS_ERROR_MAX_ENDSTOP_PRESSED = 0x2000,
    AXIS_ERROR_ESTOP_REQUESTED = 0x4000,
    AXIS_ERROR_HOMING_WITHOUT_ENDSTOP = 0x20000,
    AXIS_ERROR_OVER_TEMP = 0x40000,
    AXIS_ERROR_UNKNOWN_POSITION = 0x80000,
    AXIS_ERROR_UNKNOWN = 0xFFFFFFFFF
};

// Motor error codes
enum MotorError {
    MOTOR_ERROR_NONE = 0x00000000,
    MOTOR_ERROR_PHASE_RESISTANCE_OUT_OF_RANGE = 0x00000001,
    MOTOR_ERROR_PHASE_INDUCTANCE_OUT_OF_RANGE = 0x00000002,
    MOTOR_ERROR_ADC_FAILED = 0x00000004,
    MOTOR_ERROR_DRV_FAULT = 0x00000008,
    MOTOR_ERROR_CONTROL_DEADLINE_MISSED = 0x00000010,
    MOTOR_ERROR_NOT_IMPLEMENTED_MOTOR_TYPE = 0x00000020,
    MOTOR_ERROR_BRAKE_CURRENT_OUT_OF_RANGE = 0x00000040,
    MOTOR_ERROR_MODULATION_MAGNITUDE = 0x00000080,
    MOTOR_ERROR_BRAKE_DEADTIME_VIOLATION = 0x00000100,
    MOTOR_ERROR_UNEXPECTED_TIMER_CALLBACK = 0x00000200,
    MOTOR_ERROR_CURRENT_SENSE_SATURATION = 0x00000400,
    MOTOR_ERROR_CURRENT_LIMIT_VIOLATION = 0x00001000,
    MOTOR_ERROR_MODULATION_IS_NAN = 0x00010000,
    MOTOR_ERROR_MOTOR_THERMISTOR_OVER_TEMP = 0x00020000,
    MOTOR_ERROR_FET_THERMISTOR_OVER_TEMP = 0x00040000,
    MOTOR_ERROR_TIMER_UPDATE_MISSED = 0x00080000,
    MOTOR_ERROR_CURRENT_MEASUREMENT_UNAVAILABLE = 0x00100000,
    MOTOR_ERROR_CONTROLLER_FAILED = 0x00200000,
    MOTOR_ERROR_I_BUS_OUT_OF_RANGE = 0x00400000,
    MOTOR_ERROR_BRAKE_RESISTOR_DISARMED = 0x00800000,
    MOTOR_ERROR_SYSTEM_LEVEL = 0x01000000,
    MOTOR_ERROR_BAD_TIMING = 0x02000000,
    MOTOR_ERROR_UNKNOWN_PHASE_ESTIMATE = 0x04000000,
    MOTOR_ERROR_UNKNOWN_PHASE_VEL = 0x08000000,
    MOTOR_ERROR_UNKNOWN_TORQUE = 0x10000000,
    MOTOR_ERROR_UNKNOWN_CURRENT_COMMAND = 0x20000000,
    MOTOR_ERROR_UNKNOWN_CURRENT_MEASUREMENT = 0x40000000,
    MOTOR_ERROR_UNKNOWN_VBUS_VOLTAGE = 0x80000000,
    MOTOR_ERROR_UNKNOWN_VOLTAGE_COMMAND = 0x100000000,
    MOTOR_ERROR_UNKNOWN_GAINS = 0x200000000,
    MOTOR_ERROR_CONTROLLER_INITIALIZING = 0x400000000,
    MOTOR_ERROR_UNBALANCED_PHASES = 0x800000000,
    MOTOR_ERROR_UNKNOWN = 0xFFFFFFFFF
};

// Encoder error codes
enum EncoderError {
    ENCODER_ERROR_NONE = 0x00,
    ENCODER_ERROR_UNSTABLE_GAIN = 0x01,
    ENCODER_ERROR_CPR_POLEPAIRS_MISMATCH = 0x02,
    ENCODER_ERROR_NO_RESPONSE = 0x04,
    ENCODER_ERROR_UNSUPPORTED_ENCODER_MODE = 0x08,
    ENCODER_ERROR_ILLEGAL_HALL_STATE = 0x10,
    ENCODER_ERROR_INDEX_NOT_FOUND_YET = 0x20,
    ENCODER_ERROR_ABS_SPI_TIMEOUT = 0x40,
    ENCODER_ERROR_ABS_SPI_COM_FAIL = 0x80,
    ENCODER_ERROR_ABS_SPI_NOT_READY = 0x100,
    ENCODER_ERROR_HALL_NOT_CALIBRATED_YET = 0x200,
    ENCODER_ERROR_UNKNOWN = 0xFFFFFFFFF
};

// Controller error codes
enum ControllerError {
    CONTROLLER_ERROR_NONE = 0x00,
    CONTROLLER_ERROR_OVERSPEED = 0x01,
    CONTROLLER_ERROR_INVALID_INPUT_MODE = 0x02,
    CONTROLLER_ERROR_UNSTABLE_GAIN = 0x04,
    CONTROLLER_ERROR_INVALID_MIRROR_AXIS = 0x08,
    CONTROLLER_ERROR_INVALID_LOAD_ENCODER = 0x10,
    CONTROLLER_ERROR_INVALID_ESTIMATE = 0x20,
    CONTROLLER_ERROR_INVALID_CIRCULAR_RANGE = 0x40,
    CONTROLLER_ERROR_SPINOUT_DETECTED = 0x80,
    CONTROLLER_ERROR_UNKNOWN = 0xFFFFFFFFF
};


class ODrive {
public:
    // Constructor
    ODrive(uint8_t rx, uint8_t tx);

    // Initialize the connection to the ODrive.
    void begin();

    // Runs the full calibration sequence for the given axis, and waits for it to complete.
    void calibrate_axis(int axis);

    void set_axis_requested_state(int axis, AxisState state);

    AxisState get_axis_state(int axis);

    float get_vbus_voltage();

    void set_velocity(int axis, int vel);

    float get_current_velocity(int axis);

    AxisError get_axis_error(int axis);

    MotorError get_motor_error(int axis);

    EncoderError get_encoder_error(int axis);

    ControllerError get_controller_error(int axis);

    String get_errors(int axis);

private:
    String readString();

    void drain();

    SoftwareSerial _serial;
};

#endif // ODRIVE_H